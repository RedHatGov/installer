package airgap

import (

        "fmt"
	"os"
	//"github.com/ghodss/yaml"
	"github.com/openshift/installer/pkg/asset"
	//"github.com/openshift/installer/pkg/types"
        "github.com/spf13/viper"
)

type AirgapPackage struct {
        File   *asset.File          `json:"file"`
	url    string
	ocp_ver string
	rhcos_ver string
	platform string
	dest string
	pull_secret string
}

var _ asset.WritableAsset = (*AirgapPackage)(nil)


// Files returns the files generated by the asset.
func (a *AirgapPackage) Files() []*asset.File {
        if a.File != nil {
                return []*asset.File{a.File}
        }
        return []*asset.File{}
}

func (a *AirgapPackage) createDirectories() (err error) {

        e := os.MkdirAll(a.dest + "/registry", 0755)
        if e != nil {
                fmt.Println("Unable to create directory: " + a.dest + "/registry")
                return e
        }

        e = os.MkdirAll(a.dest + "/rhcos", 0755)
        if e != nil {
                fmt.Println("Unable to create directory: " + a.dest + "/rhcos")
                return e
        }

        e = os.MkdirAll(a.dest + "/clients", 0755)
        if e != nil {
                fmt.Println("Unable to create directory: " + a.dest + "/clients")
                return e
        }

	return nil
}

// Load returns the installconfig from disk.
func (a *AirgapPackage) Load(f asset.FileFetcher) (found bool, err error) {

	fmt.Println("Creating airgap package")

	a.ocp_ver = viper.GetString("ocp_ver")
	a.rhcos_ver = viper.GetString("rhcos_ver")
	//a.platform = viper.GetString("platform")
	a.dest = viper.GetString("dest")
	a.pull_secret = viper.GetString("pull_secret")

	e := a.createDirectories()
        if e != nil {
                fmt.Println("Unable to create directorys")
                return false, e
        }

	rhcosMeta := &rhcosReleaseMetaData{}
	mirrorRelease := &mirrorReleaseMetaData{}

	rhcosMeta.createAirgapPackage(a)
	mirrorRelease.pullClusterImages(a)
	mirrorRelease.pullRedHatOperators(a)
	mirrorRelease.pullCertifiedOperators(a)
	mirrorRelease.pullCommunityOperators(a)

	//mirrorRelease.extractInstaller(config)

	return true, nil
}

func (a *AirgapPackage) Generate(parents asset.Parents) error {
        rhcosRelease := &rhcosReleaseMetaData{}

        fmt.Println("Airgap Generate is being called")
	parents.Get(
		rhcosRelease,
	)
	//rhcosMetaData = &rhcosReleaseMetaData{}

	rhcosRelease.Generate(parents)

        return nil
}

// Dependencies returns no dependencies.
func (a *AirgapPackage) Dependencies() []asset.Asset {
	return []asset.Asset{
		&rhcosReleaseMetaData{},
                &mirrorReleaseMetaData{},
	}
        fmt.Println("In the deps")
	return nil
}

// Name returns the human-friendly name of the asset.
func (a *AirgapPackage) Name() string {
	return "Airgap Package"
}
